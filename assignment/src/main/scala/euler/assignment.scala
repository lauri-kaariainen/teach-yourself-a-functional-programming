package euler
//println(ProjectEuler.problem2)
//println(ProjectEuler.problem4)
//println(ProjectEuler.problem9)
//println(ProjectEuler.problem18)
object ProjectEuler {
  
  /*
   * Even Fibonacci numbers
   *
   * Each new term in the Fibonacci sequence is generated by adding the previous
   * two terms. By starting with 1 and 2, the first 10 terms will be:
   *
   * 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
   *
   * By considering the terms in the Fibonacci sequence whose values do not
   * exceed four million, find the sum of the even-valued terms.
   */
  def problem2(): Int = {
    
   
    
    def fib(n:Int) = fibTail(n,0,1)

    def fibTail(n:Int, a:Long, b:Long):Long = {
        if(n == 0)
            a
        else if(n == 1)
            b
        else 
            fibTail(n-1,b,a+b)
    }
    
     def findFibKeyUnderAmount(limit:Int):Int = {
      def recurv(n:Int):Int = {
        if(fib(n) > limit)
          n - 1
        else
          recurv(n+1)
      }
      recurv(0);
    }


    val ebin = List.range(1,findFibKeyUnderAmount(4000000)+1)
                                .map(fib)
                                    .filter((x)=> x % 2 == 0)
                                          .reduce((x,y) => x+y)
    ebin.toInt

  }
  

  /*
   * Largest palindrome product
   *
   * A palindromic number reads the same both ways. The largest palindrome made
   * from the product of two 2-digit numbers is 9009 = 91 Ã— 99.
   *
   * Find the largest palindrome made from the product of two 3-digit numbers.
   *
   */
  def problem4(): Int = {
    def isPalindrome(number:Int):Boolean = {
      def goThrough(thing:String):Boolean = {
        if(thing.length < 2)
            true
        else {
          if(thing.head != thing.last)
            false
          else
            goThrough(thing.tail.take(thing.length-2))
        }
      }
      goThrough(number.toString)
    }
    
    val ebin = List.range(100,1000)
                      .flatMap((x) => List.range(x*100,x*1000,x))
                              .filter(isPalindrome)
                                      .max
    ebin
    
    
    
    
  }

  /*
   * Special Pythagorean triplet
   *
   * A Pythagorean triplet is a set of three natural numbers, a < b < c, for
   * which, a^2 + b^2 = c^2
   *
   * For example, 3^2 + 4^2 = 9 + 16 = 25 = 5^2.
   *
   * There exists exactly one Pythagorean triplet for which a + b + c = 1000.
   * Find the product abc.
   */
  def problem9(): Int = {
    def isPythagoreanTriplet(lista:List[Int]):Boolean = {
      val a = lista(0)
      val b = lista(1)
      val c = lista(2)
      a < b && b < c && (a*a + b*b) == (c*c)
    }
    
    def isSpecialTriplet(lista:List[Int]):Boolean = {
      val a = lista(0)
      val b = lista(1)
      val c = lista(2)  
      a + b + c == 1000
    }
    
    
    def findProduct():Int={
      def findTriplet(a:Int,b:Int,c:Int):List[Int]={
        if(isSpecialTriplet(List(a,b,c)) && isPythagoreanTriplet(List(a,b,c)))
          List(a,b,c)
        else if(a > 333){
            List(0,0,0)
        }
        else {
          var aa = 0
          var bb = 0
          var cc = 0
          //c rolled over
          if(c > 699){
             aa = a
             bb = b+1
             cc = 0

          }
          //b rolled over
          else if(b > 699){
               aa = a+1
               bb = 0
               cc = 0
          }
          else{
             aa = a
             bb = b
             cc = c+1
          }
          
          findTriplet(aa,bb,cc)      
        }
        
      }
        
      
      
      val pythList = findTriplet(0,0,0)
      pythList(0) * pythList(1) * pythList(2)
      
    }
    
    findProduct()
    

    
  }


  /*
   * Maximum path sum I
   *
   * By starting at the top of the triangle below and moving to adjacent numbers
   * on the row below, the maximum total from top to bottom is 23.
   *
   *      3
   *     7 4
   *    2 4 6
   *   8 5 9 3
   *
   * That is, 3 + 7 + 4 + 9 = 23.
   *
   * Find the maximum total from top to bottom of the given triangle with 15
   * rows:
   */
  def problem18(triangle: List[List[Int]]): Int = {

    def getRoutesSum(depth:Int,index:Int,counter:Int,route:Int):Int={
      if(depth == triangle.length){
        counter
      }
      else{

        var newindex = 0
        //route:Int is used as a map through the tree. for example 3 == 0x0000 0011 
        //means we took the right subtree in two last steps and left in all the rest
        if((route & (1 << (triangle.length - 2 - depth))) == 0){
            newindex = index
        }
        else
          newindex = index + 1
        getRoutesSum(depth+1,newindex,counter+triangle(depth)(index),route)
      }
    }


    def getMaxPathSum(route:Int,highscore:Int):Int = {
      //are all possible routes got through
      if(route == (1 << triangle.length-1)){
      //  println("returning highscore: "+highscore)
        highscore
      }
      //  println(route +":"+(1 << (triangle.length-1)))
      else{
        var newHigh = 0
        val newScore = getRoutesSum(0,0,0,route)
        if(highscore > newScore){
          newHigh = highscore
        }
        else{
          newHigh = newScore
        //  println("highest route was "+route)
        }
        getMaxPathSum(route + 1,newHigh)
      }
    }
    getMaxPathSum(0,0)

  }

  /*
   * Maximum path sum II
   *
   * By starting at the top of the triangle below and moving to adjacent numbers
   * on the row below, the maximum total from top to bottom is 23.
   *
   *    3
   *   7 4
   *  2 4 6
   * 8 5 9 3
   *
   * That is, 3 + 7 + 4 + 9 = 23.
   *
   * Find the maximum total from top to bottom in the given triangle with
   * one-hundred rows.
   *
   * NOTE: This is a much more difficult version of Problem 18. It is not
   * possible to try every route to solve this problem, as there are 2^99
   * altogether! If you could check one trillion (10^12) routes every second it
   * would take over twenty billion years to check them all. There is an
   * efficient algorithm to solve it. ;o)
   */
  def problem67(triangle: List[List[Int]]): Int = {



    def getLargerSumFromSubTrees(depth:Int,index:Int,list:List[List[Int]]):Int={
      //left one was bigger
      if(list(depth+1)(index) >= list(depth+1)(index+1)){
        list(depth+1)(index)
      }
      //right one was
      else{
        list(depth+1)(index+1)
      }
    }
    //lessen depth by 1 per run, until we have total max sum
    def recursivelyThinArrayToFindMaxSum(newList:List[List[Int]]):Int = {
      val depth = newList.length - 2
      if(depth == 0){
        getLargerSumFromSubTrees(0,0,newList) + newList(0)(0)
      }

      else{
        var result = List[Int]()
        //array.tabulate is almost like a map-function with index
        Array.tabulate(newList(depth).length){
                    i => result = result ++ List[Int](newList(depth)(i) + getLargerSumFromSubTrees(depth,i,newList))}

        val returnList = newList.take(newList.length-2) ++ List[List[Int]](result)

        recursivelyThinArrayToFindMaxSum(returnList)
      }
    }
    recursivelyThinArrayToFindMaxSum(triangle)


  }
}
